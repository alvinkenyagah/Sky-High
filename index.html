<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky High Gamble</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #1a1a2e;
            color: white;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #16213e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #00fff2;
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0, 255, 242, 0.5);
        }

        .balance {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
        }

        #game-container {
            width: 100%;
            height: 300px;
            background-color: #0f3460;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .game-status {
            width: 100%;
            background-color: #1a508b;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .multiplier {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffde59;
        }

        .controls {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .stake-input {
            display: flex;
            flex-direction: column;
        }

        .stake-input label {
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #ccc;
        }

        input {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            background-color: #2a2a4a;
            color: white;
            font-size: 1rem;
        }

        .btn {
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .play {
            background-color: #4ade80;
            color: #111;
        }

        .play:hover {
            background-color: #22c55e;
        }

        .reset {
            background-color: #ef4444;
            color: white;
        }

        .reset:hover {
            background-color: #dc2626;
        }

        .cashout {
            width: 100%;
            background-color: #f59e0b;
            color: #111;
            font-size: 1.1rem;
            padding: 15px;
        }

        .cashout:hover {
            background-color: #d97706;
        }

        .disabled {
            background-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .disabled:hover {
            background-color: #4b5563;
        }

        .hint {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #9ca3af;
            text-align: center;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add CryptoJS for simple encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body  oncontextmenu="return false;" onkeydown="if (event.ctrlKey && event.key === 'u') return false;">
    <div class="container">
        <h1>Sky High Gamble</h1>
        <p class="balance">Balance: $<span id="balance">500.00</span></p>
        
        <div id="game-container"></div>
        
        <div class="game-status">
            <div class="multiplier"><span id="multiplier">1.00</span>x</div>
            <div id="message">Place your bet and press PLAY!</div>
        </div>
        
        <div class="controls">
            <div class="stake-input">
                <label for="stake">Stake Amount</label>
                <input type="number" id="stake" min="1" value="10">
            </div>
            
            <button id="play-btn" class="btn play">PLAY</button>
        </div>
        
        <button id="cashout-btn" class="btn cashout disabled">CASH OUT</button>
        
        <div class="hint">Try your luck, but be quick! The plane might fly away at any moment.</div>
    </div>

    <script>
        // Security key - in a real app, this would be more complex
        const SECRET_KEY = "SkyHighGamble_2025";
        
        // Game state variables
        let _gameState = {
            balance: 500,
            stake: 10,
            multiplier: 1.0,
            status: 'idle', // idle, flying, cashed, crashed
            startingBalance: 500, // Track the starting balance for validation
            startTime: null,
            sessionId: null
        };
        
        // House edge and crash point
        const HOUSE_EDGE = 0.8; // House has 80% chance to win
        let crashPoint;
        
        // Three.js components
        let scene, camera, renderer;
        let planeGroup, propeller;
        let frameId, gameLoopId;
        
        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const balanceEl = document.getElementById('balance');
        const multiplierEl = document.getElementById('multiplier');
        const messageEl = document.getElementById('message');
        const stakeInput = document.getElementById('stake');
        const playBtn = document.getElementById('play-btn');
        const cashoutBtn = document.getElementById('cashout-btn');
        
        // Generate a unique session ID
        function generateSessionId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        // Initialize game state
        function initGameState() {
            // Create a new session ID
            _gameState.sessionId = generateSessionId();
            _gameState.startTime = Date.now();
            
            // Check if there's a saved state in localStorage
            const savedState = loadGameState();
            if (savedState) {
                // Validate the saved state
                if (validateGameState(savedState)) {
                    _gameState = savedState;
                    // Make sure the game is in idle state
                    _gameState.status = 'idle';
                    _gameState.multiplier = 1.0;
                    updateUI();
                } else {
                    // If validation fails, reset to initial state
                    console.log("Invalid saved state detected, resetting game");
                    resetToInitialState();
                    saveGameState();
                }
            } else {
                // No saved state, initialize with defaults
                resetToInitialState();
                saveGameState();
            }
        }
        
        // Reset to initial state
        function resetToInitialState() {
            _gameState.balance = 500;
            _gameState.stake = 10;
            _gameState.multiplier = 1.0;
            _gameState.status = 'idle';
            _gameState.startingBalance = 500;
            _gameState.startTime = Date.now();
            // Keep the session ID
        }
        
        // Update UI elements to match game state
        function updateUI() {
            balanceEl.textContent = _gameState.balance.toFixed(2);
            multiplierEl.textContent = _gameState.multiplier.toFixed(2);
            stakeInput.value = _gameState.stake;
            
            if (_gameState.status === 'idle') {
                playBtn.textContent = 'PLAY';
                playBtn.classList.add('play');
                playBtn.classList.remove('reset');
                cashoutBtn.classList.add('disabled');
                messageEl.textContent = 'Place your bet and press PLAY!';
            }
        }
        
        // Encrypt game state for storage
        function encryptGameState(state) {
            const stateStr = JSON.stringify(state);
            const encrypted = CryptoJS.AES.encrypt(stateStr, SECRET_KEY).toString();
            return encrypted;
        }
        
        // Decrypt game state from storage
        function decryptGameState(encrypted) {
            try {
                const decrypted = CryptoJS.AES.decrypt(encrypted, SECRET_KEY).toString(CryptoJS.enc.Utf8);
                return JSON.parse(decrypted);
            } catch (e) {
                console.error("Failed to decrypt game state", e);
                return null;
            }
        }
        
        // Generate a checksum for the game state
        function generateChecksum(state) {
            const stateStr = JSON.stringify({
                balance: state.balance,
                startingBalance: state.startingBalance,
                sessionId: state.sessionId,
                startTime: state.startTime
            });
            return CryptoJS.SHA256(stateStr + SECRET_KEY).toString();
        }
        
        // Save game state to localStorage
        function saveGameState() {
            const stateToSave = { ..._gameState };
            // Add a checksum to verify integrity
            stateToSave.checksum = generateChecksum(stateToSave);
            
            // Encrypt before saving
            const encrypted = encryptGameState(stateToSave);
            localStorage.setItem('skyHighGameState', encrypted);
        }
        
        // Load game state from localStorage
        function loadGameState() {
            const encrypted = localStorage.getItem('skyHighGameState');
            if (!encrypted) return null;
            
            return decryptGameState(encrypted);
        }
        
        // Validate game state for tampering
        function validateGameState(state) {
            // Check if essential properties exist
            if (!state || typeof state.balance !== 'number' || 
                typeof state.startingBalance !== 'number' || 
                !state.sessionId || !state.startTime) {
                return false;
            }
            
            // Validate starting balance (should always be 500)
            if (state.startingBalance !== 500) {
                return false;
            }
            
            // Verify checksum
            const expectedChecksum = generateChecksum(state);
            if (state.checksum !== expectedChecksum) {
                return false;
            }
            
            // Validate balance range
            if (state.balance < 0 || state.balance > 10000) {
                return false;
            }
            
            return true;
        }
        
        // Initialize Three.js scene
        function initScene() {
            console.log("Initializing Three.js scene...");
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f3460);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, gameContainer.clientWidth / gameContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            gameContainer.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);
            
            // Ground (runway)
            const groundGeometry = new THREE.PlaneGeometry(30, 6);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            scene.add(ground);
            
            // Create airplane
            createAirplane();
            
            // Start animation loop
            animate();
        }
        
        // Create airplane
        function createAirplane() {
            planeGroup = new THREE.Group();
            
            // Fuselage
            const fuselageGeometry = new THREE.CylinderGeometry(0.2, 0.15, 1.2, 8);
            const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red for visibility
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            fuselage.rotation.z = Math.PI / 2;
            planeGroup.add(fuselage);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.8, 0.05, 0.4);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x3366CC });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            planeGroup.add(wings);
            
            // Tail
            const tailGeometry = new THREE.BoxGeometry(0.25, 0.3, 0.05);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0x3366CC });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.x = -0.5;
            tail.position.y = 0.15;
            planeGroup.add(tail);
            
            // Propeller
            propeller = new THREE.Group();
            const hubGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.05, 8);
            const hubMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.rotation.z = Math.PI / 2;
            propeller.add(hub);
            
            const bladeGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.02);
            const bladeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const blade1 = new THREE.Mesh(bladeGeometry, bladeMaterial);
            const blade2 = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade2.rotation.z = Math.PI / 2;
            propeller.add(blade1);
            propeller.add(blade2);
            
            propeller.position.x = 0.62;
            planeGroup.add(propeller);
            
            // Initial position - on the runway
            planeGroup.position.set(-4, -0.8, 0);
            scene.add(planeGroup);
        }
        
        // Animation loop
        function animate() {
            frameId = requestAnimationFrame(animate);
            
            // Rotate propeller if game is active
            if (_gameState.status !== 'idle' && propeller) {
                propeller.rotation.x += 0.5;
            }
            
            renderer.render(scene, camera);
        }
        
        // Generate crash point with house edge
        function generateCrashPoint() {
            const random = Math.random();
            
            // Apply house edge
            if (random < HOUSE_EDGE) {
                // Early crash (house wins)
                return 1.0 + (random * 0.5);
            } else {
                // Better odds for player
                return 1.5 + (random * 8.5); // Can go up to 10x
            }
        }
        
        // Start the game
        function startGame() {
            if (_gameState.status !== 'idle') return;
            
            const stakeAmount = parseFloat(stakeInput.value);
            if (isNaN(stakeAmount) || stakeAmount <= 0 || stakeAmount > _gameState.balance) {
                messageEl.textContent = 'Invalid stake amount!';
                return;
            }
            
            _gameState.stake = stakeAmount;
            
            // Determine crash point with house edge
            crashPoint = parseFloat(generateCrashPoint().toFixed(2));
            
            // Update balance
            _gameState.balance -= _gameState.stake;
            balanceEl.textContent = _gameState.balance.toFixed(2);
            
            // Save state after deducting stake
            saveGameState();
            
            // Update game state
            _gameState.status = 'flying';
            _gameState.multiplier = 1.0;
            multiplierEl.textContent = '1.00';
            messageEl.textContent = 'Plane is taking off!';
            
            // Update buttons
            playBtn.textContent = 'RESET';
            playBtn.classList.remove('play');
            playBtn.classList.add('reset');
            cashoutBtn.classList.remove('disabled');
            
            // Reset plane position
            planeGroup.position.set(-4, -0.8, 0);
            planeGroup.rotation.x = 0;
            planeGroup.rotation.z = 0;
            
            // Game loop - increase multiplier over time
            let currentMultiplier = 1.0;
            let flightPhase = 'takeoff';
            
            gameLoopId = setInterval(() => {
                currentMultiplier += 0.01;
                
                // Update multiplier display
                _gameState.multiplier = parseFloat(currentMultiplier.toFixed(2));
                multiplierEl.textContent = _gameState.multiplier.toFixed(2);
                
                // Animate the plane based on flight phase
                if (flightPhase === 'takeoff') {
                    // Takeoff animation
                    planeGroup.position.x += 0.03;
                    if (planeGroup.position.y < 0.5) {
                        planeGroup.position.y += 0.03;
                        planeGroup.rotation.z = Math.min(planeGroup.rotation.z + 0.01, 0.2);
                    } else {
                        flightPhase = 'climbing';
                    }
                } else if (flightPhase === 'climbing') {
                    // Climbing animation
                    planeGroup.position.x += 0.04;
                    planeGroup.position.y += 0.04;
                    planeGroup.rotation.z = Math.min(planeGroup.rotation.z + 0.005, 0.3);
                    
                    if (planeGroup.position.y > 1.5) {
                        flightPhase = 'cruising';
                    }
                } else if (flightPhase === 'cruising') {
                    // Cruising animation
                    planeGroup.position.x += 0.05;
                }
                
                // Check if we've hit the crash point
                if (currentMultiplier >= crashPoint) {
                    // Crash the plane - fly away animation
                    clearInterval(gameLoopId);
                    _gameState.status = 'crashed';
                    messageEl.textContent = `Plane flew away at ${crashPoint.toFixed(2)}x!`;
                    cashoutBtn.classList.add('disabled');
                    
                    // Save state after crash
                    saveGameState();
                    
                    // Animate the plane flying away rapidly
                    const flyAway = () => {
                        planeGroup.position.y += 0.15;
                        planeGroup.position.x += 0.15;
                        planeGroup.rotation.z += 0.05;
                        
                        if (planeGroup.position.y < 6) {
                            requestAnimationFrame(flyAway);
                        }
                    };
                    
                    flyAway();
                }
            }, 100);
        }
        
        // Cash out
        function cashOut() {
            if (_gameState.status !== 'flying') return;
            
            clearInterval(gameLoopId);
            
            // Calculate winnings properly
            const originalStake = _gameState.stake;
            const winnings = originalStake * _gameState.multiplier;
            const profit = winnings - originalStake;
            
            // Update balance with winnings
            _gameState.balance += winnings;
            balanceEl.textContent = _gameState.balance.toFixed(2);
            
            _gameState.status = 'cashed';
            messageEl.textContent = `Cashed out at ${_gameState.multiplier.toFixed(2)}x! Won $${profit.toFixed(2)} profit on $${originalStake.toFixed(2)} stake.`;
            cashoutBtn.classList.add('disabled');
            
            // Save state after cashout
            saveGameState();
            
            // Continue flying animation but level out
            const levelOut = () => {
                planeGroup.position.x += 0.05;
                
                // Level out the plane
                if (planeGroup.rotation.z > 0) {
                    planeGroup.rotation.z -= 0.01;
                }
                
                if (planeGroup.position.x < 10) {
                    requestAnimationFrame(levelOut);
                }
            };
            
            levelOut();
        }
        
        // Reset the game
        function resetGame() {
            if (_gameState.status === 'idle') return;
            
            clearInterval(gameLoopId);
            _gameState.status = 'idle';
            _gameState.multiplier = 1.0;
            multiplierEl.textContent = '1.00';
            messageEl.textContent = 'Place your bet and press PLAY!';
            
            // Update buttons
            playBtn.textContent = 'PLAY';
            playBtn.classList.remove('reset');
            playBtn.classList.add('play');
            cashoutBtn.classList.add('disabled');
            
            // Save state after reset
            saveGameState();
        }
        
        // Handle window resize
        function handleResize() {
            camera.aspect = gameContainer.clientWidth / gameContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
        }
        
        // Event listeners
        playBtn.addEventListener('click', () => {
            if (_gameState.status === 'idle') {
                startGame();
            } else {
                resetGame();
            }
        });
        
        cashoutBtn.addEventListener('click', cashOut);
        window.addEventListener('resize', handleResize);
        
        // Initialize the game
        window.addEventListener('DOMContentLoaded', () => {
            initGameState();
            initScene();
        });
    </script>
</body>
</html>